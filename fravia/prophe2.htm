<HTML>  

<HEAD>

<!--  formamus.htm version 02 February 1998 

INSTRUCTIONS FOR SUBMITTING: DO NOT USE HTML EDITORS!  

SEARCH THIS TEXT FOR THE STRING "Your_"   

AND REPLACE WITH WHATEVER YOU WANT TO PUBLISH!

 THANKS A LOT: this will allow automated retrieval -->

<TITLE>prophe_2.htm Dirtbike: a cute protection scheme</TITLE>

</HEAD>

<BODY BGCOLOR=#C0C0C0 TEXT=#001010 VLINK=#405040>  

<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%  HEIGHT=" 22">  

<TR><td></td>  

<td>  

<!-- Choose  a TITLE probably wont be changed -->  

<center><FONT SIZE="+2">Dirtbike:</fonT><br>  

        <FONT SIZE="+1">A cute protection scheme</fonT>  

</center>  

</td>  

  

<td>  

<!-- Choose  a PROJECT GIF, leave this if unsure -->  

<center><a href="student.htm#student_loo_na" tppabs="http://www.anticrack.de/fravia/student.htm#student_loo_na"><IMG SRC="notassi3.gif" tppabs="http://www.anticrack.de/fravia/notassi3.gif" ALT="student"   

ALIGN=CENTER WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0   

HSPACE=0></a>  

<br>  

<font color=gray>Not Assigned</FonT>  

</center></td></tr>  

<tR>  

<td bgcolor="#FFFFEA"><center>  

<FONT COLOR="890000">  

<!-- CHOOSE A DATE (will probably be changed) -->  15 July 1998  

</FONT></center>  

</td>  

<td bgcolor="#FFFFEA"><center>by <font size=+3>  

<!-- CHOOSE A HANDLE (wont be changed) -->  

Prophecy  

</fonT></center>  

</td>  

<td VALIGN="center" bgcolor="#FFFFEA">  

<!--  

<a href="hcu98_3.htm" tppabs="http://www.anticrack.de/fravia/hcu98_3.htm"><IMG SRC="hcu1.gif" tppabs="http://www.anticrack.de/fravia/hcu1.gif" ALT="+cracker" ALIGN=BOTTOM   

WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0></a>  

-->  

</td>  

</tr>  

<TR><td><center><a href="index.html" tppabs="http://www.anticrack.de/fravia/index.html"><IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALIGN="BOTTOM"   

BORDER="0" VSPACE="0" HSPACE="0" width="13" height="13"></a></center></td>  

<TD BGCOLOR="898030"><center>Courtesy of Fravia's page of   

reverse engineering</center>   

</center></TD>  

<td BGCOLOR="898030">  

<center>  

<!-- Your truly+ will edit only if really necessary -->  

slightly edited<br>  

by fravia+</center></td>  

</TR>  

<!-- this is for the data.....fra_00xx....yymmdd....handle..beg+int...not ass... -->  

<tr><td><font color="#C4C0CF">fra_00xx<bR>98xxxx<br>handle<br>1100<br>NA<br>PC<br></fonT></td><td><i><center>  

<!-- Your truly+ comments -->

Well, I hope Prophecy will send a more 'generic' essay next time: I believe that this kind 

of reversing approach may be very useful if the cracker demonstrates a little more its 

'generical' (i.e. not target-specific) validity. Anyway this is a nice essay and the keygen in C at the 

bottom can be easily re-used for your own probes. Enjoy!</i></center></td>  

<td></td>  

</tr>  

<TR><td></td>  

<!-- Leonard Coehn's old song, because we are poets, not only crackers -->  

<TD BGCOLOR="898030"><center></i><b>There is a crack, a crack in everything   

That's how the light gets in</b></center>  

<!-- Leonard Coehn's old song, because we are poets, not only crackers -->  

</center></TD><td></td>  

</TR>  

<TR>  

<td VALIGN= "MIDDLE" bgcolor="#C6E7C6"><font color=blue><center>  

Rating</FONT></FONT></center>  

</TD>  

<td VALIGN = "MIDDLE" bgcolor="#C6E7C6"><font color=blue><center>  

<!-- CHOOSE A RATING (may be changed) -->  

( )<B>Beginner</B> (x)<B>Intermediate</B> ( )<B>Advanced</B> ( )<B>Expert</B></FONT>  

</center></td>  

<td></td>  

</tr>  

</table>  

<!-- END HEAD  -->  

<bR>  

<!-- CORPUS  -->

<!-- CHOOSE A COMMENT (may be changed)  -->  

This essay illustrates the concept of using a magic buffer to validate a code  

and to generate your name.  

  

<hR>  

<center>  

   <FONT SIZE="+2">  

<!-- CHOOSE A TITLE (wont probably be changed) -->  

Dirtbike:  

   </FONT><BR>  

   <FONT SIZE="+2">  

<!-- CHOOSE A SUBTITLE (wont proabbly be changed) -->  

A cute protection scheme  

   </FONT><BR>  

   <FONT COLOR="0B7FC1">  

<!-- REPEAT YOUR CHOSEN HANDLE HERE -->Written by   

<A HREF="mailto:prophecy_@usa.net">Prophecy</A>  

   </FONT>  

</center><br><br>  

  

<!-- INTRO STARTS HERE -->  

<pre>  

<FONT  SIZE=+2><B>INTRODUCTION:</B></font>  

  

Howdy guys, it's me again.  If you're still a newbie i suggest you read my  

<A HREF="prophe_1.htm" tppabs="http://www.anticrack.de/fravia/prophe_1.htm">beginner tut</A> and the other beginner essays on this site before attempting  

this tut.  

  

A while ago this dude called theKrow popped into #cracking4newbies and asked  

someone to crack Dirt Bike for him,  stating that all it required was a single  

registration number.  I thought, heh, this'll be a quick crack, probably only  

has one valid serial hard coded into the .exe.  Anyway, being the nice guy I  

am, I downloaded Dirt Bike and set to work.  

  

As it turned out the protection scheme was actually a lot more complicated than  

it should've been for a US $15 shareware, and  I thought I'd share it with ya  

because it's a cute little scheme which I haven't seen or read about before.  

  

I'll step ya thru the code, explaining the steps and at the end show you how to  

write the keygen for it using C.  

  

<B><I><U>A note to good beginners/intermediate crackers:</U>  I suggest you download the  

target and have a go at cracking it yerself before reading this tut as it is a  

good academic exercise :)</I></B>  

  

<FONT  SIZE=+2><B>TARGET:</B></font>  

  

Well the target is called Dirt Bike (v4.4).  It's quite an addictive/cool little  

motocross side-on-view simulator which you can download here:  

  

<A HREF="javascript:if(confirm('http://members.aol.com/bradquick/homepage.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://members.aol.com/bradquick/homepage.html'" tppabs="http://members.aol.com/bradquick/homepage.html">http://members.aol.com/bradquick/homepage.html</A>  

  

<FONT  SIZE=+2><B>TOOLS:</B></font>  

  

The only tool you'll need is the kick arse debugger SoftIce by NuMega.  

  

Optionally, if you want to compile the C code for the keygen you'll also need  

a C compiler surprisingly enough.  

  

Also SoftDump written by the legendary +Quine is handy too!  

  

<FONT  SIZE=+2><B>LET'S GET STARTED:</B></font>  

  

First have a quick read of the docs... it might give you some handy tips  

regarding the protection and what to expect.  In this case it doesn't.  

  

Now, let's load up the target and have a look round there... hrmm the first  

thing that pops up is a box asking for a registration number... click on  

<font color=green>'Not Yet'</font>.  You'll see the Dirt Bike splash screen and in the bottom right  

corner it says <font color=green>'This copy is registered to Unregistered'</font>.  Well we can deduce  

from this that the single code we enter must somehow contain our name.  Not  

the quick crack I had originally anticipated :)  

  

<FONT  SIZE=+2><b>Part 0:  Breaking into the target</B></font>  

  

Ok, enough pissing round, let's reverse this mudda.  You'll find <B>bpx hmemcpy</B>  

works here.  Ok bang we're in SoftIce, hit <font color=green>&lt;F11&gt;</font> once and then search for the  

bogus code you entered.  I found mine at <B>a1fbe8</B>, set a <B>bpr</B> on it and hit  

<font color=green>&lt;F5&gt;</font>... you'll end up here:  

  

(<U>Note:</U>  lines of code in <B>bold</B> are important and a '.' means unimportant code  

        has been removed)  

  

<font color=blue>00417395  INC     ECX  

00417396  MOV     EAX,EDX  

00417398  INC     EDX  

00417399  CMP     BYTE PTR [EAX],00</font> <- softice breaks here  

<font color=blue>0041739C  JNZ     00417395  

0041739E  MOV     EAX,ECX  

004173A0  RET</font>  

  

Well, this is just a simple routine to get the length of your code.  The length  

is stored in <font color=red>ECX</font>, which is then moved to <font color=red>EAX</font>.  Ok leave that call, and you'll  

pop out at here:  

  

<font color=blue>004106B0  CALL    0041738C</font> &lt;trace down until you hit the JB&gt;  

<font color=blue>004106B5  ADD     ESP,04  

.  

.  

004106BD  JB      0041068E</font>  

^ this takes us to the start of Part 1:  

  

  

<FONT  SIZE=+2><b>Part 1: the checksum</B></font>  

  

<font color=blue>0041068E  CMP     DWORD PTR [EBP-59],03  

00410692  JNZ     0041069D  

00410694  MOV     DWORD PTR [EBP-59],00000000</font> ;set counter=0  

<font color=blue>0041069B  JMP     004106AA  

0041069D  MOV     ECX,[EBP-5D]</font>  

^ move counter (initally set at 4) into <font color=red>ECX</font>  

<font color=blue>004106A0  MOV     EAX,[EBP+08]</font> ;move address of bogus code into eax  

<font color=blue><B>004106A3  MOVSX   EDX,BYTE PTR [ECX+EAX]</B></font>  

^ move nth char of bogus code into <font color=red>edx</font>, where n is 5,6,7...  

<font color=blue><B>004106A7  ADD     [EBP-55],EDX</B></font>  

^ add the char to <font color=red>[EBP-55]</font> which has an initial value of 0x231  

<font color=blue>004106AA  INC     DWORD PTR [EBP-5D]</font> ;increment counter  

<font color=blue>004106AD  PUSH    DWORD PTR [EBP+08]</font>  

<font color=purple>004106B0  CALL    0041738C</font> ;get length of code again  

<font color=blue>004106B5  ADD     ESP,04</font> ;stack correction i do believe :)  

<font color=blue>004106B8  MOV     EDX,EAX</font> ;move length into <font color=red>edx</font>  

<font color=blue>004106BA  CMP     [EBP-5D],EDX</font> ;reached end of code yet?  

<font color=blue>004106BD  JB      0041068E</font> ;no/yes  

  

--------------------------------------------------------------------------------  

<I>So this snippet of code is adding the ascii values of the 5th, 6th etc... chars  

of your registration number to the initial value of 0x231... i'm calling this  

a checksum.</I>  

--------------------------------------------------------------------------------  

  

<font color=blue>004106BF  JMP     004106C8  

<B>004106C1  SUB     DWORD PTR [EBP-55],00000141  

004106C8  CMP     DWORD PTR [EBP-55],0000270F  

004106CF  JG      004106C1</B></font>  

^Is checksum > 0x270f?  If so, subtract 0x141 until it ain't.  

<font color=blue>004106D1  JMP     004106DA  

<B>004106D3  ADD     DWORD PTR [EBP-55],00001984  

004106DA  CMP     DWORD PTR [EBP-55],000003E8  

004106E1  JL      004106D3</B></font>  

^Is checksum < 0x3e8?  If so, add 0x1984 until it ain't.  

  

  

<FONT  SIZE=+2><b>Part 2: backtracking</B></font>  

  

Now a bit later on this prog uses a 'magic number' to check if your code is  

valid.  This magic number is displayed in memory.  I used a technique which I  

call backtracking to find the place the magic number was generated. Backtracking  

is simple, yet powerful:  you know that after you've stepped over a call, the  

magic number has been generated as you can see it in the data window.  So you  

know you had to step into that call.  So <font color=green>&lt;F5&gt;</font> out of SoftIce and start again,  

this time making sure you actually step into that call.  You repeat this  

procedure until you reach the code generating routine.  

  

<font color=blue>004106E3  LEA     EAX,[EBP-4D]  

004106E6  PUSH    EAX</font>  

^this is actually the location the magic number (<i>m</i>) is stored, as you can  

quickly determine by typing <B>d eax</B> and stepping over the next call.  

<font color=blue>004106E7  PUSH    DWORD PTR [EBP-55]</font>  

<font color=purple>004106EA  CALL    004050D2</font> ;step into here to goto magic number routine  

  

If you did the above correctly, you should be somewhere around <B>BFF796A6</B>.   

Anyway, although we don't know it yet, this snippet actually generates the  

aforementioned magic number in reverse (i'll call it <i>k</i>)...:  

  

  

<FONT  SIZE=+2><b>Part 3: manipulating the checksum</B></font>  

  

<font color=blue><B>BFF796A6</B>  MOV     EDI,[ESP+18]</font> ;move our checksum into <font color=red>EDI</font>  

<font color=blue>BFF796AA  MOV     EBX,[ESP+20]</font> ;move a constant 0xa into <font color=red>EBX</font>  

<font color=blue>BFF796AE  MOV     EBP,[ESP+14]</font> ;move address of <I>k</I> into <font color=red>EBP</font>  

<font color=blue>BFF796B2  MOV     EAX,EDI</font> ;move checksum into <font color=red>EAX</font>  

<font color=blue>BFF796B4  SUB     EDX,EDX</font> ;set <font color=red>edx</font>=0  

<font color=blue><B>BFF796B6  DIV     EBX</B></font>  

^aha, the crucial step.  This divides the contents of <font color=red>EAX</font> by the constant 0xa,  

storing the quotient in <font color=red>EAX</font> and the modulus (remainder) in <font color=red>EDX</font>.  

<font color=blue>BFF796B8  MOV     ECX,EDX</font> ;move modulus into <font color=red>ECX</font>  

<font color=blue>BFF796BA  MOV     EAX,EDI</font> ;move checksum back into <font color=red>EAX</font>  

<font color=blue>BFF796BC  SUB     EDX,EDX</font> ;set ecx=0  

<font color=blue><B>BFF796BE  ADD     ECX,30</B></font>  

^adds 0x30 to the modulus (interesting eh?)  

<font color=blue><B>BFF796C1  DIV     EBX</font> ;same as above</B>  

<font color=blue>BFF796C3  MOV     EDI,EAX</font> ;store new quotient in <font color=red>EDI</font>  

<font color=blue>.  

BFF796CE  INC     ESI ;increase counter  

<B>BFF796CF  MOV     [EBP+00],CL</font> ;stored first number of <I>k</I> into <font color=red>EBP</font></B>  

<font color=blue>BFF796D2  INC     EBP</font> ;ready <font color=red>EBP</font> to store next char of <I>k</I>  

<font color=blue>BFF796D3  CMP     [ESP+1C],ESI</font> ;compare counter with 4  

<font color=blue>BFF796D7  JL      BFF796DD</font> ;if less, repeat procedure  

<font color=blue>.</font>  

  

--------------------------------------------------------------------------------  

<I>So quite a neat little process:  

  

The checksum is divided by 0xa, and the result (</i>a<i>) and modulus (</i>b<i>) are stored in  

the <font color=red>eax</font> and <font color=red>edx</font> registers.  then 0x30 is added to </i>b<i> to give the first digit of  

</i>k<i>.  The process is repeated to obtain the 2nd, 3rd and 4th numbers of </i>k<i>.  

  

Later on, this number is reversed, we'll call it '</i>m<i>'. So that if we obtained a  

number 2307, we'd now have 7032.  

  

BTW, Natzgul pointed out to me that all that happend was the checksum was  

converted from hex to decimal... <sheepish grin>.  

  

Okay, hightail outta here, and press <font color=green>&lt;F12&gt;</font> a  

few times till your back in the dirt bike proggie...:</I>  

--------------------------------------------------------------------------------  

  

  

<FONT  SIZE=+2><b>Part 4: verifying the code and introducing the magic buffer</B></font>  

  

<font color=blue>004106EF  ADD     ESP,08</font> ;correct the ol' stack  

<font color=blue>004106F2  MOV     DWORD PTR [EBP-5D],00000000</font> ;set counter=0  

<font color=blue>004106F9  JMP     0041071F  

004106FB  MOV     EAX,[EBP-5D]</font> ;set <font color=red>EAX</font>=counter  

<font color=blue>004106FE  MOV     ECX,[EBP-5D]</font> ;set <font color=red>ECX</font>=counter  

<font color=blue><B>00410701  MOVSX   EDX,BYTE PTR [EAX+EBP-4D]</B></font>  

^<font color=red>[EBP-4D]</font> = <I>m</I> remember?  And <font color=red>EAX</font>=counter, so this line moves the nth char of <I>m</I>  

into <font color=red>EDX</font>, where n=1,2,3 and 4. (loops around)  

<font color=blue><B>00410706  ADD     EDX,-24</B></font> ;subtract 0x24 from ascii value of nth char of <I>m</I>  

<font color=blue>00410709  MOV     EAX,[EBP+08]</font> ;move address of bogus code into <font color=red>EAX</font>  

<font color=blue><B>0041070C  MOV     BL,[EDX+EBP-43]</B></font>  

  

--------------------------------------------------------------------------------  

<I>Hrmm by now you've probably noticed the following hairy beast:  

  

<font color=purple>XcgjH3uKTawSL6CrGRUJvFyAfkNBQsMEzPoDxtqZ78einYpWdhmVb4...</font> intrigueing, isn't it?  

  

EBP-43 is the starting address of that big long thing which i'm calling the  

"magic buffer".  So basically, the target is is getting the ascii val of the  

number of </I>k<I>, subracting 0x24 from it (i'll call this number </I>n<I>).  Then it  

takes the (n+1)th char of the magic buffer and compares it to the 1st, 2nd etc  

char of your bogus code... you dig?</I>  

--------------------------------------------------------------------------------  

  

<b><font color=blue>00410710  CMP     BL,[ECX+EAX]</font> ;compares as described above</b>  

<font color=blue>00410713  JZ      0041071C</font> ;jump good guy, otherwise continue  

<font color=blue>00410715  MOV     DWORD PTR [EBP-51],00000000</font> ;set bad_guy flag  

<font color=blue>0041071C  INC     DWORD PTR [EBP-5D]</font> ;increase counter  

<font color=blue>0041071F  CMP     DWORD PTR [EBP-5D],04</font> ;are we done yet?  

<font color=blue>00410723  JL      004106FB</font> ;y/n (if not repeat procedure using next digit of <I>k</I>)  

<font color=blue>00410725  CMP     DWORD PTR [EBP-51],00</font> ;is the bad_guy flag set?  

<b><font color=blue>00410729  JNZ     00410756</font> ;the infamous jump hehe (jump to good guy if not 0)</B>  

  

--------------------------------------------------------------------------------  

<I>At this point i simply reversed the jump (<B>r fl z</B>) and hit <font color=green>&lt;F5&gt;</font> out of softice  

and sure enuf, it said registered but displayed garbage in the <font color=green>'registered  

to'</font> section.  Naturally my next inclination was to get da prog to display  

Prophecy [tNO] or something like that instead so....:</I>  

--------------------------------------------------------------------------------  

  

  

<FONT  SIZE=+2><b>Part 5:  How the prog works out who it's registered to</B></font>  

  

This is another kinda cool part of this protection- it uses the magic buffer to  

determine what's gonna get displayed in the <font color=green>'registered to'</font> section. So keep  

tracing down the code until you reach:  

  

<font color=blue>00410768  MOV     ECX,[EBP-5D]</font> ;<font color=red>[ebp-5d]</font> is a counter, initially set at 4  

<font color=blue>0041076B  MOV     EAX,[EBP+08]</font> ;put address of code into <font color=red>eax</font>  

<font color=blue>0041076E  MOV     DL,[ECX+EAX]</font> ;put (n+1)th char of code into DL, where n=value  

<font color=blue>.                                                                 </font>of <font color=red>[ebp-5d]</font>  

<font color=blue>00410787  MOV     EAX,[EBP-59]</font> ;set <font color=red>eax</font>=counter2 (initially 0)  

<font color=blue>0041078A  MOV     ECX,[EBP-5D]</font> ;set <font color=red>ecx</font>=counter  

<font color=blue>0041078D  MOV     BL,[EAX+EBP-43]</font> ;take (counter2)th char of magic buffer  

<font color=blue>00410791  MOV     EAX,[EBP+08]</font> ;move address of code into <font color=red>EAX</font>  

<font color=blue>00410794  CMP     BL,[ECX+EAX]</font> ;cmp (counter)th char of our code with <font color=red>bl</font>  

<font color=blue>00410797  JNZ     00410809</font>  

^ if chars not the same, repeat procedure until end of buffer is reached  

<font color=blue><b>00410799  CMP     DWORD PTR [EBP-59],1A</b></font>  

^ compares count with 0x1a (which is 26 in decimal!)  

<font color=blue>0041079D  JGE     004107B4</font> ;jump if >= 0x1a  

<font color=blue>0041079F  MOV     DL,[EBP-59]  

<B>004107A2  ADD     DL,41</b></font>  

  

--------------------------------------------------------------------------------  

<I>adds 0x41 to the <b>count</b>.  The count is the number of iterations required to  

find the (counter)th char of our code in the magic buffer.  As the length of  

the buffer is 0x36, the values of counter range from 0x0 to 0x35.  So, the  

minimum amount of counts required is 0, this means DL would be 0x41, which  

corresponds to the ascii value 'A'... interesting.</I>  

--------------------------------------------------------------------------------  

<font color=blue>.  

<B>004107B4  CMP     DWORD PTR [EBP-59],34</font> ;cmp count with 0x34</B>  

<font color=blue>004107B8  JGE     004107D2</font> ;jump if >= 0x34  

<font color=blue>.  

<b>004107C0  ADD     DL,47</b></font>  

^so if the minimum count possible to reach this section is 0x1a, which procures  

an ascii value of 'a' when 0x47 is added to it.  

<font color=blue>.  

<B>004107D2  CMP     DWORD PTR [EBP-59],34</B>  

.  

<B>004107E1  MOV     BYTE PTR [EDX+EAX+00000380],2E</B></font>  

^if count=0x34, then name of our char gets mapped to a '.' (ascii val of 0x2e)  

<font color=blue>.  

<B>004107EB  CMP     DWORD PTR [EBP-59],35</B>  

.  

<B>004107FA  MOV     BYTE PTR [EDX+EAX+00000380],20</B></font>  

^if count=0x34, then name of our char gets mapped to a ' ' (ascii val of 0x20)  

  

the rest of the code basically goes back and compares the char of code with  

next char of magic buffer, then goes onto the next letter of code when it has  

decided whether or not the code was found in the magic buffer.  

  

also, if the char is not found in the magic buffer, then the prog will just  

use that char (you can confirm this by entering a code whose char ain't in the  

magic buffer... you'll see it displayed in the <font color=green>'registered to'</font> part)  

  

--------------------------------------------------------------------------------  

<i>So, if you studied the above code carefully, you would've figured out by  

now how the prog works out what chars it's gonna stick in the <font color=green>'Registered to'</font>  

section...  

  

</i>If you want: <font color=blue>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.</font>  

             ||||||||||||||||||||||||||||||||||||||||||||||||||||||  

then enter : <font color=purple>XcgjH3uKTawSL6CrGRUJvFyAfkNBQsMEzPoDxtqZ78einYpWdhmVb4</font><i>  

  

If the letter ain't found in the magic buffer, then don't modify it in any  

way... so that's the protection unveiled! Simple eh?</i>  

--------------------------------------------------------------------------------  

  

  

<FONT  SIZE=+2><b>Part 6: Example - calculating a valid code for 'bob'</B></font>  

  

Well, by now you should know that the code is of the form <font color=purple>'xxxxyyy'</font>, where  

<font color=purple>'xxxx'</font> are the <font color=blue>4</font> digits which are compared with modified checksum. So, follow  

these simple steps:  

  

<B>(1)</B> from table above, we know we have to enter <font color=purple>xxxx<B>B7B</B></font>.  We also know that  

<font color=purple>'xxxx'</font> depends on <font color=purple><B>B7B</B></font>, so let's work that out now.  

  

<B>(2)</B> ascii values of <font color=blue>B</font>,<font color=blue>7</font> and <font color=blue>B</font> are added to initial val of <font color=red>0x213</font>:  

   <font color=blue>0x42+0x37+0x42+</font><font color=red>0x213</font>=<font color=blue>0x2ce</font> (call this sum <i>i</i>)  

  

<B>(3)</B> is i > <font color=blue>0x270f</font>? if so, subtract <font color=blue>0x141</font> until it isn't  

  

<B>(4)</B> then, is i < <font color=red>0x3e8</font>?  if so, add <font color=red>0x1984</font> until it isn't  

   hence, <i>j</i>=<i>i</i>+<font color=red>0x1984</font>=<font color=blue>0x2ce+</font><font color=red>0x1984</font>=<font color=blue>0x1c52</font>  

  

<B>(5)</B> <i>j</i> is now divided by <font color=red>0xa</font>, and the result (<i>a</i>) and modulus (<i>b</i>) are  

stored in the <font color=red>eax</font> and <font color=red>edx</font> registers.  then <font color=red>0x30</font> is added to <i>b</i> to give the  

first digit of the new code, let's call it <i>k</i>.  The process is then repeated  

again <font color=blue>3</font> times so that you are left with a <font color=blue>4</font> digit code <i>k</i>:  

  

<font color=blue>0x1c52</font>/<font color=red>0xa</font>=<font color=blue>0x2d5</font> modulus <font color=blue>0x0</font>, hence char <B>1</B> = <font color=blue>0x30</font> (<B>0</B>)  

 <font color=blue>0x2d5</font>/<font color=red>0xa</font>=<font color=blue>0x48</font>  modulus <font color=blue>0x5</font>, hence char <B>2</B> = <font color=blue>0x35</font> (<B>5</B>)  

  <font color=blue>0x48</font>/<font color=red>0xa</font>=<font color=blue>0x7</font>   modulus <font color=blue>0x2</font>, hence char <B>3</B> = <font color=blue>0x32</font> (<B>2</B>)  

   <font color=blue>0x7</font>/<font color=red>0xa</font>=<font color=blue>0x0</font>   modulus <font color=blue>0x7</font>, hence char <B>4</B> = <font color=blue>0x37</font> (<B>7</B>)  

  

This gives a value of <B>0527</B> for <i>k</i>.  

  

<B>(6)</B> This number is reversed, to give our magic number <i>m</i>: <B>7250</B>  

  

<B>(7)</B> Now, it takes the ascii value of the first char (<font color=blue>0x37</font>) and subtracts 0x24:  

   <font color=blue>0x37-</font><font color=red>0x24</font>=<font color=blue>0x13</font> (call this <i>n</i>)  

  

<B>(8)</B> It now checks the first char of our code with the (n+1)th char of the magic  

buffer:  

  

<font color=purple>XcgjH3uKTawSL6CrGRUJvFyAfkNBQsMEzPoDxtqZ78einYpWdhmVb4</font> (magic buffer)  

  

Hence:  <B>char1:</B> <font color=blue>0x37-</font><font color=red>0x24</font>=<font color=blue>0x13, <B>0x14th</B></font> char of buffer: <B>J</B>  

        <B>char2:</B> <font color=blue>0x32-</font><font color=red>0x24</font>=<font color=blue>0xe , <B>0xfth</B></font>  char of buffer: <B>C</B>  

        <B>char3:</B> <font color=blue>0x35-</font><font color=red>0x24</font>=<font color=blue>0x11, <B>0x12th</B></font> char of buffer: <B>R</B>  

        <B>char4:</B> <font color=blue>0x30-</font><font color=red>0x24</font>=<font color=blue>0xc , <B>0xdth</B></font>  char of buffer: <B>L</B>  

  

As the <B>J,C,R</B> and <B>L</B> are compared to the first <font color=blue>4</font> chars of our registration  

number, this means that these are the valid values for the 'xxxx' component  

of our code...  

  

<B>(9)</B> So, the full code for 'bob' is:  <B>JCRLB7B</B> ... you dig?  Hope so :)  

  

  

<FONT  SIZE=+2><b>Part 7: Keygen</B></font>  

  

I've written a keygen for this target in C, you shouldn't have too much trouble  

following it:  

  

<B>---------------------------------START OF KEYGEN--------------------------------</B>  

<font color=purple>/* C sorce file, compiled with borland c++ 5.02  

 *  

 * this source has been included with this keygen for educational purposes, so  

 * other crackers wanting to learn can do so by examining this source file.  

 *  

 * it is quite conceivable that a later version of this software gets released  

 * which uses the same protection scheme.  in such cases my keygen be packaged  

 * with the software as long as the source is included in the keygen archive.  

 *  

 * however, modifying this source to make it look like it was written by  

 * someone else from some other group is simply lame.  

 *  

 * if the software HAS changed it's protection scheme, include the source  

 * with your keygen to prove it.  

 */</font>  

<font color=green>#include &lt;stdio.h>  

#include &lt;string.h>  

#include &lt;ctype.h>  

#include &lt;conio.h></font>  

  

<B>int</B> main()<B>{</B>  

  

<B>unsigned char</B> name[<font color=blue>500</font>]=<B>{</B><font color=blue>0</font><B>}</B>, temp[<font color=blue>5</font>]=<B>{</B><font color=blue>0</font><B>}</B>;  

<B>unsigned char</B> m[<font color=blue>5</font>]=<B>{</B><font color=blue>0</font><B>}</B>, first4chars[<font color=blue>5</font>]=<B>{</B><font color=blue>0</font><B>}</B>, lastchars[<font color=blue>500</font>]=<B>{</B><font color=blue>0</font><B>}</B>;  

<B>unsigned char</B> magicbuffer[<font color=blue>0x37</font>]=<font color=blue>"XcgjH3uKTawSL6CrGRUJvFyAfkNBQsMEzPoDxtqZ78einYpWdhmVb4"</font>;  

<B>unsigned char</B>      buffer[<font color=blue>0x37</font>]=<font color=blue>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz. "</font>;  

<B>unsigned int</B> i=<font color=blue>0</font>,j,k=<font color=blue>0</font>,n,a,b;  

<B>int</B> y=<font color=blue>0</font>,z=<font color=blue>0</font>,length=<font color=blue>0</font>;  

  

tryagain: <font color=purple>/* go back here if user stuffs up */</font>  

length=0; <font color=purple>/* reset length of name */</font>  

clrscr();  

  

printf("éüüüüüüü É üüü – üüüüüüü É üüüüüüüüüüüü¯\n");  

printf("ú˛§§æ˛§§§æ˛§§æ˛§§æ–   –æ§æ ˛æ§§æ˛§§§æ˛ Ñ\n");  

printf("Ñ  ˛É §§§æ §É  §§§˛æ– §§§æ  §§§æ §§§æ  Ñ\n");  

printf("Ñ    É§§§æ    É§§§  §§§§§æ É§§§æ §§§æ  Ñ\n");  

printf("Ñ   –æ§§§æ–  –æ§§§æ– ˛æ§§æ–æ§§§æ–æ§§æ– Ñ\n");  

printf("øüüüüüüüüüüüüüüüüüüüüü ˛˛æ üüüüüüüüüüüüç\n");  

printf("\nKey Generator for Dirtbike v4.4");  

printf("\nWritten by Prophecy [tNO]\n\n");  

  

printf("Please enter your name:  ");  

gets(name);  

  

<font color=purple>/* work out length */</font>  

  

<B>while</B> (name[length] != '\0')<B>{</B>  

	length++;  

<B>}</B>  

  

<B>if</B>(length==0)<B>{</B>  

	printf("\n\n *** You didn't enter a name!  Try again... ***");  

	getch();  

	goto tryagain;  

<B>}</B>  

  

<B>if</B>(length>50)<B>{</B>  

	printf("\n\n *** Your name is too long.  Try again... ***");  

	getch();  

	goto tryagain;  

<B>}</B>  

  

<font color=purple>/* convert the name entered into their corresponding letters from the magic  

   buffer */</font>  

  

<B>for</B>(y=0;y&lt;length;y++)<B>{</B>  

	<B>while</B>(((buffer[z]-name[y]) != 0) && (buffer[z] != '\0'))<B>{</B>  

		z++;  

	<B>}</B>  

	<B>if</B>(magicbuffer[z]=='\0')<B>{</B> <font color=purple>/* if char not found in buffer */</font>  

		lastchars[y]=name[y]; /* use the value from the name as is */  

	<B>}</B>  

  

	<B>else{</B>  

		lastchars[y]=magicbuffer[z]; <font color=purple>/* else use the char from the magic buffer */</font>  

	<B>}</B>  

	z=0;  

<B>}</B>  

  

<font color=purple>/* work out 'i' */</font>  

  

<B>for</B>(z=0;z<=length;z++)<B>{</B>  

	i+=lastchars[z];  

<B>}</B>  

i+=0x213;  

  

<font color=purple>/* go thru steps (3) and (4) */</font>  

  

<B>while</B>(i>0x270f)<B>{</B>  

	i-=0x141;  

<B>}</B>  

  

<B>while</B>(i<0x3e8)<B>{</B>  

	i+=0x1984;  

<B>}</B>  

j=i; <font color=purple>/* using same variables as in comments */</font>  

a=j;  

  

<font color=purple>/* work out k */</font>  

<B>for</B>(z=0;z<4;z++)<B>{</B>  

	b=a%0xa; <font color=purple>/* modulus (remainder) */</font>  

	a/=0xa; <font color=purple>/* quotient */</font>  

	k=(k*10) + b;  

<B>}</B>  

  

<font color=purple>/* find out m (ie reverse k) */</font>  

  

y=0;  

sprintf(temp, "%04d", k);  

<B>for</B>(z=3;z>=0;z--)<B>{</B>  

	m[y]=temp[z];  

	y++;  

<B>}</B>  

  

<font color=purple>/* work out the first 4 digits of your valid code */</font>  

  

<B>for</B>(z=0;z<4;z++)<B>{</B>  

	n=(m[z]-0x24);  

	first4chars[z]=magicbuffer[n];  

<B>}</B>  

  

printf("\nYour reigistration code is:  %s%s",first4chars,lastchars);  

  

return 0;  

<B>}</B>  

<B>----------------------------------END OF KEYGEN---------------------------------</B>  

  

  

<FONT  SIZE=+2><b>Part 8:  Other miscellaneous points</b></font>  

  

You may have noticed this prog stores the regcode in a file called register.dbk  

which is exactly 100 bytes long.  Hence as a safeguard in my keygen I  

specified the max length of the name as being 50 chars long... although you  

could probly get away with 85 chars or something (couldn't be bothered finding  

out)...  This is a trivial point but hey, everything counts!  

  

  

<FONT  SIZE=+2><B>Greetz</B></font>  

  

<U>Greetz fly out to:</U>  

  

Cali, Natzgul, ZEN-crack, eagle (see, I learned... doesn't my tut look  

beautiful? :), to^clean, dasmonkey, Twister, the #cracking4newbies crew,  

the +HCUkers and fravia!  

  

  

<FONT  SIZE=+2><b>Conclusion:</b></font>  

  

I hoped this tut has helped you in one way or another.  

  

You can send me praise and abuse at: <A HREF="mailto:prophecy_@usa.net">prophecy_@usa.net</A>  

  

Have a good one, and may the (zen) force be with you!  

  

<B>Veni vidi vici.</B>  

</pre>  

<br><br>  

  

<!-- OB DUH STARTS HERE -->  

<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >  

<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Ob Duh</fonT></fonT>  

</center></td></tr></table>  

 <center>  

   <i>I wont even bother explaining you   

   that you should BUY this target program if you intend to use it for a longer   

   period than the allowed one. Should you want   

   to STEAL this software instead, you don't need to crack its protection   

   scheme at all: you'll   

   find it on most Warez sites, complete and already regged, farewell.</i>  

</center>  

  

<!-- WAY OUT STARTS HERE -->  

<hr>  

<center><i>You are deep inside fravia's page of reverse engineering,    

choose your way out:</i></center>  

<br><center>  

<!-- EITHER A NICE GIF LIKE THIS -->  

  

<!--   

<a href="project3.htm" tppabs="http://www.anticrack.de/fravia/project3.htm"><IMG SRC="project3.gif" tppabs="http://www.anticrack.de/fravia/project3.gif"   

ALT="projecT3" ALIGN=CENTER WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0></a>  

<br>  

<font color=gray>Back to project 3</FonT>  

<br><bR>  

-->  

  

<!-- OR JUST A LINK LIKE THIS -->  

  

<!--  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="project1.htm" tppabs="http://www.anticrack.de/fravia/project1.htm">Back to Your_chosen_project</A>   

<hr width=33%>  

-->  

  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="index.html" tppabs="http://www.anticrack.de/fravia/index.html">homepage</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="links.htm" tppabs="http://www.anticrack.de/fravia/links.htm">links</A>   

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="searengi.htm" tppabs="http://www.anticrack.de/fravia/searengi.htm">search_forms</A>  

  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="orc.htm" tppabs="http://www.anticrack.de/fravia/orc.htm">+ORC</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="student.htm" tppabs="http://www.anticrack.de/fravia/student.htm">students' essays</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="academy.htm" tppabs="http://www.anticrack.de/fravia/academy.htm">academy database</A>  

<br>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="realicra.htm" tppabs="http://www.anticrack.de/fravia/realicra.htm">reality cracking</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="howtosea.htm" tppabs="http://www.anticrack.de/fravia/howtosea.htm">how to search</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="javascri.htm" tppabs="http://www.anticrack.de/fravia/javascri.htm">javascript wars</A>  

<br>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="tools.htm" tppabs="http://www.anticrack.de/fravia/tools.htm">tools</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="noanon.htm" tppabs="http://www.anticrack.de/fravia/noanon.htm">anonymity academy</A>   

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="cocktail.htm" tppabs="http://www.anticrack.de/fravia/cocktail.htm">cocktails</A>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="ideale.htm" tppabs="http://www.anticrack.de/fravia/ideale.htm">antismut CGI-scripts</A>  

  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="info.htm" tppabs="http://www.anticrack.de/fravia/info.htm">mail_fravia+</A>  

<br>  

<IMG SRC="bulletr.gif" tppabs="http://www.anticrack.de/fravia/bulletr.gif" ALT="red" ALIGN=BOTTOM WIDTH=13 HEIGHT=13   

BORDER=0 VSPACE=0 HSPACE=0><A HREF="legal.htm" tppabs="http://www.anticrack.de/fravia/legal.htm">Is reverse engineering legal?</A>  

</CENTER>  

<hr>  



<!-- THAT'S ALL, THANKS A LOT this will allow automated retrieval -->  

</BODY></HTML>